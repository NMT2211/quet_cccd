<!doctype html>
<html lang="vi">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Qu√©t QR CCCD + Chuy·ªÉn ƒë·ªïi ƒë·ªãa ch·ªâ m·ªõi</title>
  
<link rel="icon" type="image/png" href="./assets/fav.png">
  <!-- Local lib -->
  <script src="./assets/html5-qrcode.min.js"></script>

  <!-- ‚úÖ Xu·∫•t Excel (XLSX) ‚Äì n·∫øu offline/CDN l·ªói s·∫Ω fallback CSV -->
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>

  <!-- ‚úÖ OCR (fallback) -->
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>

  <link rel="stylesheet" href="style.css">

  <style>
    :root{
      /* Colors */
      --bg:#ffffff;
      --surface:#ffffff;
      --surface2:#f7f8fb;
      --text:#0f172a;
      --muted:#475569;
      --line:#e5e7eb;

      --btn:#2563eb;
      --btn2:#16a34a;
      --danger:#dc2626;
      --warn:#d97706;

      /* UI tokens */
      --radius:18px;
      --radius2:14px;

      /* Shadows */
      --shadow: 0 10px 22px rgba(15,23,42,.08);
      --shadow2: 0 16px 36px rgba(15,23,42,.10);

      /* Typography (<=700) */
      --base: clamp(15px, 1.6vw, 16px);
      --h1: clamp(18px, 2.6vw, 22px);
      --label: 13px;
      --control: 16px;

      /* Touch targets */
      --tap: 46px;
    }

    *{box-sizing:border-box}
    html,body{height:100%}

    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
      font-size: var(--base);
      background: var(--bg);
      color: var(--text);
      /* padding: 16px; */
      line-height: 1.55;
      -webkit-font-smoothing: antialiased;
      text-rendering: optimizeLegibility;
      width: 100;
    }

    .wrap{
    max-width: 1700px;
    margin:24px auto;
    display:grid;
    gap:14px; 
    padding: 15px;
  }

    /* Header */
    .top{
      display:flex; gap:12px; flex-wrap:wrap;
      align-items:center; justify-content:space-between;
      padding: 14px 14px;
      border:1px solid var(--line);
      border-radius: var(--radius);
      background: var(--surface);
      box-shadow: var(--shadow);
    }

    h1{
      margin:0;
      font-size:var(--h1);
      font-weight:700;
      letter-spacing:.1px;
    }

    .pill{
      display:inline-flex;align-items:center;gap:8px;
      padding:10px 12px;border-radius:999px;
      border:1px solid var(--line);
      background: var(--surface2);
      color: var(--muted);
      font-size:13px;
      font-weight:600;
      white-space:nowrap;
    }

    /* Layout */
    .grid{
      display:grid;
      grid-template-columns: minmax(320px, 420px) 1fr;
      gap:14px;
      align-items:start;
    }

    @media (max-width: 980px){
      /* body{padding:12px} */
      .grid{grid-template-columns:1fr}
      .top{align-items:flex-start}
    }

    .card{
      background: var(--surface);
      border:1px solid var(--line);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 14px;

    }

    .row{display:flex;gap:10px;flex-wrap:wrap}
    .row.between{justify-content:space-between; align-items:center}

    label{
      display:block;
      font-size: var(--label);
      color: var(--muted);
      margin: 10px 0 6px;
      font-weight:600;
    }

    input, textarea, select{
      width:100%;
      border-radius: var(--radius2);
      border:1px solid var(--line);
      background: #fff;
      color: var(--text);
      padding: 12px 12px;
      outline:none;
      font-size: var(--control);
      min-height: var(--tap);
    }
    textarea{min-height:110px;resize:vertical}

    input:focus, textarea:focus, select:focus{
      border-color: rgba(37,99,235,.55);
      box-shadow: 0 0 0 4px rgba(37,99,235,.12);
    }

    /* Buttons */
    .btn{
      cursor:pointer;
      border:1px solid transparent;
      padding: 12px 14px;
      border-radius: var(--radius2);
      color:white;
      font-weight:600;
      background: var(--btn);
      font-size: 15px;
      min-height: var(--tap);
      min-width: 140px;
      transition: .15s transform, .15s opacity, .15s box-shadow;
    }
    .btn:hover{opacity:.96}
    .btn:active{transform: translateY(1px)}
    .btn.secondary{
      background: #fff;
      color: var(--text);
      border-color: var(--line);
    }
    .btn.ok{background: var(--btn2)}
    .btn.danger{background: var(--danger)}
    .btn:disabled{opacity:.55; cursor:not-allowed}

    /* Reader */
    #reader{
      border-radius: 16px;
      overflow:hidden;
      border:2px solid rgba(37,99,235,.16);
      background: var(--surface2);
      min-height: 420px;
      display:flex;
      align-items:center;
      justify-content:center;
    }
    #reader video{
      width:100% !important;
      height:100% !important;
      object-fit: cover !important;
    }
    #reader img{
  width:100% !important;
  height:100% !important;
  object-fit: contain !important; /* mu·ªën ‚Äúgi·ªëng camera‚Äù h∆°n th√¨ ƒë·ªïi th√†nh cover */
  display:block;
}


    .status{
      margin-top:10px;
      color: var(--muted);
      font-size: 13px;
      line-height:1.55;
    }
    .warn{color: var(--warn); font-weight:600}
    .error{color: var(--danger); font-weight:600}
    .oktxt{color: #16a34a; font-weight:600}

    .small{font-size:13px;color:var(--muted)}
    code.inline{
      background: var(--surface2);
      padding:2px 8px;
      border-radius:10px;
      border:1px solid var(--line);
      font-size: 12.5px;
    }

    /* Info table */
    .kv{
      display:grid;
      grid-template-columns: 160px 1fr auto;
      gap:10px;
      padding:12px 0;
      border-top:1px solid var(--line);
    }
    .kv:first-child{border-top:0}
    .k{color:var(--muted);font-size:13px;align-self:center;font-weight:600}
    .v{font-weight:600; align-self:center; word-break: break-word}
    .mono{font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace}

    .copyBtn{
      padding:10px 12px;
      border-radius: 12px;
      border:1px solid var(--line);
      background: var(--surface2);
      color: var(--text);
      font-weight:600;
      cursor:pointer;
      min-height: var(--tap);
      white-space:nowrap;
    }
    .copyBtn:hover{opacity:.96}

    .two{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:12px;
    }

    @media (max-width: 640px){
      .two{grid-template-columns:1fr}
      .btn{min-width: 100%}
      #reader{min-height: 520px;}
      .kv{grid-template-columns: 1fr; gap:6px}
      .copyBtn{width:100%}
    }

    /* Sticky actions mobile */
    @media (max-width: 640px){
      .stickyActions{
        position: sticky;
        top: 10px;
        z-index: 5;
        background: var(--surface);
        padding-bottom: 10px;
        border-radius: 16px;
      }
    }

    hr{border:0;border-top:1px solid var(--line);margin: 12px 0}

    .toast{
      position: fixed;
      right: 14px;
      bottom: 14px;
      background: rgba(15,23,42,.92);
      border: 1px solid rgba(255,255,255,.18);
      padding: 12px 14px;
      border-radius: 14px;
      font-size: 13px;
      color: #fff;
      display:none;
      max-width: 420px;
      box-shadow: 0 14px 30px rgba(0,0,0,.18);
      z-index: 60;
    }

    #oldAddr, #addrFull { font-weight: 600; }

    /* =======================
       Modal nh·∫≠p ph√≤ng
       ======================= */
    .modalOverlay{
      position: fixed;
      inset: 0;
      background: rgba(15,23,42,.55);
      display:none;
      align-items:center;
      justify-content:center;
      padding: 16px;
      z-index: 50;
    }
    .modal{
      width: min(520px, 100%);
      background: var(--surface);
      border: 1px solid var(--line);
      border-radius: 18px;
      box-shadow: var(--shadow2);
      padding: 14px;
      max-height: min(78vh, 720px);
      overflow:auto;
    }
    .modalTitle{
      font-size: 17px;
      font-weight: 700;
      margin: 0;
    }
    .modalSub{
      margin-top: 6px;
      color: var(--muted);
      font-size: 13px;
      line-height: 1.45;
    }
    .modalActions{
      margin-top: 12px;
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      justify-content:flex-end;
    }
    .modal .btn{min-width: 140px}
    @media (max-width: 420px){
      .modalActions .btn{min-width: 100%}
    }

    /* =======================
       B·∫£ng t·∫°m (Excel-like)
       ======================= */
    .tmpWrap{
      margin-top: 14px;
      border: 1px solid var(--line);
      border-radius: var(--radius);
      overflow: hidden;
      background: #fff;
      box-shadow: var(--shadow);
    }
    .tmpToolbar{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
      justify-content:space-between;
      padding: 10px 10px;
      background: var(--surface2);
      border-bottom: 1px solid var(--line);
    }
    .tmpToolbar .left{display:flex;gap:10px;flex-wrap:wrap;align-items:center;}
    .tmpToolbar .right{display:flex;gap:8px;flex-wrap:wrap;align-items:center;}

    .tmpTableScroll{
      overflow:auto;
      max-height: 320px;
      -webkit-overflow-scrolling: touch;
    }
    table.tmpTable{
      width: 100%;
      border-collapse: collapse;
      min-width: 920px;
    }
    .tmpTable th, .tmpTable td{
      border-bottom: 1px solid var(--line);
      padding: 10px 10px;
      font-size: 13px;
      vertical-align: top;
    }
    .tmpTable th{
      position: sticky;
      top: 0;
      background: #fff;
      z-index: 2;
      font-weight: 700;
      text-align: left;
      white-space: nowrap;
    }
    .tmpTable td{
      word-break: break-word;
      max-width: 360px;
    }
    .tmpEmpty{
      padding: 14px;
      color: var(--muted);
      font-size: 13px;
    }
    .miniBtn{
      padding: 8px 10px;
      border-radius: 12px;
      border: 1px solid var(--line);
      background: #fff;
      cursor: pointer;
      font-weight: 700;
      min-height: 40px;
    }
    .miniBtn:hover{opacity:.96}
    .miniBtn.danger{border-color: rgba(220,38,38,.35); color: var(--danger)}

    /* ‚úÖ Mobile: b·∫£ng t·∫°m hi·ªÉn th·ªã d·∫°ng card */
    @media (max-width: 640px){
      table.tmpTable{min-width: 0;}
      .tmpTable thead{display:none;}
      .tmpTable, .tmpTable tbody, .tmpTable tr, .tmpTable td{display:block; width:100%;}
      .tmpTable tr{
        border-bottom: 1px solid var(--line);
        padding: 10px 10px;
      }
      .tmpTable td{
        border:0;
        padding: 8px 0;
        max-width: none;
        display:flex;
        gap:10px;
        align-items:flex-start;
      }
      .tmpTable td::before{
        content: attr(data-label);
        min-width: 140px;
        color: var(--muted);
        font-weight: 600;
      }
      .tmpToolbar .right{width:100%}
      .tmpToolbar .right .miniBtn{flex:1}
    }

    /* =======================
       Tabs: QR upload / OCR
       ======================= */
    .tabs{
      display:flex;
      gap:8px;
      margin-top: 12px;
      flex-wrap:wrap;
    }
    .tabBtn{
      padding: 10px 12px;
      border-radius: 999px;
      border: 1px solid var(--line);
      background: var(--surface2);
      color: var(--text);
      font-weight: 700;
      cursor:pointer;
      min-height: 42px;
    }
    .tabBtn.active{
      background: var(--btn);
      color:#fff;
      border-color: rgba(37,99,235,.35);
    }
    .tabPane{
      display:none;
      margin-top: 10px;
      padding-top: 8px;
    }
    .tabPane.active{display:block}

    .noticeBox{
      border: 1px solid rgba(217,119,6,.35);
      background: rgba(217,119,6,.08);
      color: #8a4b00;
      padding: 10px 12px;
      border-radius: 14px;
      font-size: 13px;
      line-height: 1.5;
    }
    .noticeBox b{color:#6b3b00}
  </style>
</head>
<body>
  <div id="nav-host"></div>

  <div class="wrap">
    <div class="top">
      <div>
        <h1>Qu√©t QR CCCD ‚Üí L·∫•y th√¥ng tin + Chuy·ªÉn ƒë·ªïi ƒë·ªãa ch·ªâ m·ªõi</h1>
        <div class="small" style="margin-top:6px">
          Qu√©t QR / OCR ·∫£nh CCCD ‚Üí t·ª± g·ªçi API chuy·ªÉn ƒë·ªïi ƒë·ªãa ch·ªâ ‚Üí l∆∞u b·∫£ng t·∫°m ‚Üí xu·∫•t Excel
        </div>
      </div>
      <div class="pill" id="libStatus">üì¶ ƒêang ki·ªÉm tra th∆∞ vi·ªán qu√©t QR...</div>
    </div>

    <div class="grid">
      <!-- LEFT -->
      <div class="card">
        <div class="row between stickyActions">
          <div style="font-weight:700;font-size:16px">üì∑ Qu√©t QR b·∫±ng camera</div>
          <div class="row">
            <button class="btn" id="btnStart">B·∫Øt ƒë·∫ßu qu√©t</button>
            <button class="btn secondary" id="btnStop" disabled>D·ª´ng</button>
          </div>
        </div>

        <div style="height:12px"></div>
        <div id="reader"></div>

        <div class="status" id="scanStatus">Tr·∫°ng th√°i: <b>Ch∆∞a qu√©t</b></div>

        <!-- ‚úÖ Tabs: Upload QR / OCR CCCD -->
        <div class="tabs" role="tablist" aria-label="Ch·ªçn ch·∫ø ƒë·ªô ·∫£nh">
          <button class="tabBtn active" id="tabQrBtn" type="button" role="tab" aria-selected="true" aria-controls="tabQrPane">
            üßæ ·∫¢nh QR
          </button>
          <button class="tabBtn" id="tabOcrBtn" type="button" role="tab" aria-selected="false" aria-controls="tabOcrPane">
            üß† OCR CCCD
          </button>
        </div>

        <!-- TAB 1: Upload QR -->
        <div class="tabPane active" id="tabQrPane" role="tabpanel" aria-labelledby="tabQrBtn">
          <label>T·∫£i ·∫£nh QR (·∫£nh c√≥ QR ·ªü m·∫∑t sau CCCD)</label>
          <input id="qrFile" type="file" accept="image/*" />
          <div class="small">M·∫πo: ch·ª•p g·∫ßn, n√©t, kh√¥ng rung, tr√°nh ch√≥i.</div>
        </div>

        <!-- TAB 2: OCR CCCD -->
        <div class="tabPane" id="tabOcrPane" role="tabpanel" aria-labelledby="tabOcrBtn">
          <div class="noticeBox">
            <b>‚ö†Ô∏è L∆∞u √Ω:</b> OCR c√≥ th·ªÉ sai (ƒë·∫∑c bi·ªát ·∫£nh m·ªù/ch√≥i). H√£y <b>ki·ªÉm tra l·∫°i th√¥ng tin</b> sau khi OCR xong tr∆∞·ªõc khi l∆∞u/xu·∫•t.
          </div>

          <div style="height:10px"></div>

          <label>T·∫£i ·∫£nh CCCD ƒë·ªÉ OCR (m·∫∑t tr∆∞·ªõc)</label>
          <input id="idFile" type="file" accept="image/*" />

          <label style="margin-top:10px">Groq API Key</label>
          <input id="groqKey" type="password" placeholder="Bearer gsk_..." value="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"/>


          <label style="margin-top:10px">Model Vision</label>
          <select id="groqModel">
            <option value="meta-llama/llama-4-scout-17b-16e-instruct" selected>Llama 4 Scout (Vision)</option>
            <option value="meta-llama/llama-4-maverick-17b-128e-instruct">Llama 4 Maverick (Vision)</option>
          </select>

          <div class="row" style="margin-top:10px">
            <button class="btn ok" id="btnOcrId" disabled>üß† OCR CCCD</button>
            <button class="btn secondary" id="btnOcrClear" disabled>X√≥a ·∫£nh</button>
          </div>
          <div class="status" id="ocrStatus">OCR: ‚Äî</div>
        </div>

        <hr />

        <label>Ho·∫∑c d√°n chu·ªói QR th·ªß c√¥ng (h·ªó tr·ª£ 2 d·∫°ng)</label>
        <textarea id="rawInput" placeholder='VD 1: 034205011440|Nguy·ªÖn Minh Tu·∫•n|22082005|Nam|T·ªï 4B, Kp 1, H·ªôi Nghƒ©a, Th·ªã x√£ T√¢n Uy√™n, B√¨nh D∆∞∆°ng|19042021

VD 2 (d·∫°ng c√≥ nh√£n):
S·ªë CCCD: 034205011440
H·ªç v√† t√™n: Nguy·ªÖn Minh Tu·∫•n
Gi·ªõi t√≠nh: Nam
Ng√†y sinh: 22/08/2005
N∆°i th∆∞·ªùng tr√∫: T·ªï 4B, Kp 1, H·ªôi Nghƒ©a, T√¢n Uy√™n, B√¨nh D∆∞∆°ng
Ng√†y c·∫•p CCCD: 19/04/2021'></textarea>

        <div class="row" style="margin-top:10px">
          <button class="btn secondary" id="btnParse">Parse + t·ª± chuy·ªÉn ƒë·ªïi</button>
          <button class="btn danger" id="btnClear">X√≥a</button>
        </div>

        <div class="status">
          üí° ƒêi·ªán tho·∫°i: d√πng camera sau + b·∫≠t flash + zoom 2x‚Äì3x ƒë·ªÉ b·∫Øt QR nh·ªè.
        </div>
      </div>

      <!-- RIGHT -->
      <div class="card">
        <div style="display:flex;justify-content:space-between;align-items:center;gap:10px;flex-wrap:wrap;">
          <div style="font-weight:700;font-size:16px">ü™™ Th√¥ng tin ƒë·ªçc ƒë∆∞·ª£c</div>
          <div class="row" style="gap:8px">
            <button class="copyBtn" id="btnCopyAll">üìã Copy t·∫•t c·∫£</button>
            <button class="copyBtn" id="btnSaveTmp">üß† L∆∞u t·∫°m</button>
            <button class="copyBtn" id="btnGoCT01">üìù ƒêi·ªÅn CT01</button>
            <button class="copyBtn" id="btnSendTelegram">üì® G·ª≠i Telegram</button>

          </div>
        </div>

        <div class="small" style="margin-top:6px">
          ƒê√£ l∆∞u: <b id="savedCount">0</b> d√≤ng (b·∫£ng t·∫°m)
        </div>

        <div style="height:10px"></div>

        <div id="infoBox">
          <div class="kv"><div class="k">S·ªë CCCD</div><div class="v mono" id="cccd">‚Äî</div><button class="copyBtn" data-copy="#cccd">Copy</button></div>
          <div class="kv"><div class="k">H·ªç t√™n</div><div class="v" id="name">‚Äî</div><button class="copyBtn" data-copy="#name">Copy</button></div>
          <div class="kv"><div class="k">Ng√†y sinh</div><div class="v" id="dob">‚Äî</div><button class="copyBtn" data-copy="#dob">Copy</button></div>
          <div class="kv"><div class="k">Gi·ªõi t√≠nh</div><div class="v" id="gender">‚Äî</div><button class="copyBtn" data-copy="#gender">Copy</button></div>
          <div class="kv"><div class="k">ƒê·ªãa ch·ªâ (c≈©)</div><div class="v" id="oldAddr">‚Äî</div><button class="copyBtn" data-copy="#oldAddr">Copy</button></div>
          <div class="kv"><div class="k">Ng√†y c·∫•p</div><div class="v" id="issue">‚Äî</div><button class="copyBtn" data-copy="#issue">Copy</button></div>
        </div>

        <hr />

        <div class="row between">
          <div>
            <div style="font-weight:700;font-size:16px">üîÅ ƒê·ªãa ch·ªâ m·ªõi (t·ª± ƒë·ªông)</div>
            <div class="small">POST <code class="inline">/api/v1/convert/address</code> (Bearer API key)</div>
          </div>
        </div>

        <div style="height:10px"></div>

        <div class="two">
          <div>
            <label>API Key (Bearer)</label>
            <!-- üîí Khuy·∫øn ngh·ªã: ƒë·ªÉ tr·ªëng, nh·∫≠p khi ch·∫°y -->
            <input id="apiKey" type="password" placeholder="Authorization: Bearer ..." value="hvn_76s2V2WDzr9au59x6SFfZDzL1VYhby8p"/>
          </div>
          <div>
            <label>Ch·∫ø ƒë·ªô d√≤ m√£ h√†nh ch√≠nh</label>
            <select id="mode">
              <option value="smart" selected>T·ª± t√°ch & d√≤ m√£ t·ª´ ƒë·ªãa ch·ªâ</option>
              <option value="manual">Nh·∫≠p tay province/district/ward + street</option>
            </select>
          </div>
        </div>

        <div class="two" id="manualCodes" style="display:none; margin-top: 8px">
          <div><label>provinceCode</label><input id="provinceCode" placeholder="VD: 74" /></div>
          <div><label>districtCode</label><input id="districtCode" placeholder="VD: 723..." /></div>
          <div><label>wardCode</label><input id="wardCode" placeholder="VD: 257..." /></div>
          <div><label>streetAddress</label><input id="streetAddress" placeholder="VD: T·ªï 4B, Kp 1" /></div>
        </div>

        <div class="status" id="convertStatus" style="margin-top:12px">‚Äî</div>

        <div style="height:8px"></div>

        <div id="newBox">
          <div class="kv"><div class="k">ƒê·ªãa ch·ªâ t·ªïng</div><div class="v" id="addrFull">‚Äî</div><button class="copyBtn" data-copy="#addrFull">Copy</button></div>
          <div class="kv"><div class="k">T·ªânh/Th√†nh ph·ªë *</div><div class="v" id="addrProvince">‚Äî</div><button class="copyBtn" data-copy="#addrProvince">Copy</button></div>
          <div class="kv"><div class="k">X√£/Ph∆∞·ªùng/ƒê·∫∑c khu *</div><div class="v" id="addrWard">‚Äî</div><button class="copyBtn" data-copy="#addrWard">Copy</button></div>
          <div class="kv"><div class="k">S·ªë nh√†/·∫§p/KP/ƒê∆∞·ªùng</div><div class="v" id="addrStreet">‚Äî</div><button class="copyBtn" data-copy="#addrStreet">Copy</button></div>
        </div>

        <label style="margin-top:12px">Log k·ªπ thu·∫≠t</label>
        <textarea id="log" readonly class="mono" placeholder="Log request/response s·∫Ω hi·ªán ·ªü ƒë√¢y..."></textarea>
      </div>
    </div>

    <!-- ‚úÖ B·∫¢NG T·∫†M -->
    <div class="tmpWrap">
      <div class="tmpToolbar">
        <div class="left">
          <div style="font-weight:700">üß† B·∫£ng t·∫°m</div>
          <div class="small">L∆∞u nhi·ªÅu ng∆∞·ªùi r·ªìi m·ªõi xu·∫•t file</div>
        </div>
          <div class="right">
            <button class="miniBtn" id="btnExportExcelInTable">üìÑ Xu·∫•t Excel</button>
            <button class="miniBtn" id="btnSendTelegramTmpAll">üì® G·ª≠i Tele (t·∫•t c·∫£)</button>
            <button class="miniBtn danger" id="btnClearTmpAll">üóë X√≥a h·∫øt</button>
          </div>

      </div>

      <div class="tmpTableScroll" id="tmpTableScroll">
        <div class="tmpEmpty" id="tmpEmpty">Ch∆∞a c√≥ d√≤ng n√†o. B·∫•m ‚Äúüß† L∆∞u t·∫°m‚Äù ƒë·ªÉ th√™m.</div>
        <table class="tmpTable" id="tmpTable" style="display:none">
          <thead>
            <tr id="tmpHead"></tr>
          </thead>
          <tbody id="tmpBody"></tbody>
        </table>
      </div>
    </div>
  </div>

  <div class="toast" id="toast"></div>

  <!-- ‚úÖ MODAL NH·∫¨P PH√íNG -->
  <div class="modalOverlay" id="roomModal">
    <div class="modal" role="dialog" aria-modal="true" aria-labelledby="roomModalTitle">
      <div class="row between" style="align-items:flex-start">
        <div>
          <p class="modalTitle" id="roomModalTitle">Nh·∫≠p s·ªë ph√≤ng (t√πy ch·ªçn)</p>
          <div class="modalSub">
            B·∫°n c√≥ th·ªÉ nh·∫≠p s·ªë ph√≤ng ƒë·ªÉ l∆∞u chung trong Excel, ho·∫∑c b·∫•m ‚ÄúB·ªè qua‚Äù n·∫øu kh√¥ng c·∫ßn.
          </div>
        </div>
        <button class="miniBtn" id="btnCloseRoomModal" aria-label="ƒê√≥ng">‚úï</button>
      </div>

      <label>S·ªë ph√≤ng</label>
      <input id="roomModalInput" placeholder="VD: 101 / A12..." />

      <div class="modalActions">
        <button class="btn secondary" id="btnRoomCancel">H·ªßy</button>
        <button class="btn secondary" id="btnRoomSkip">B·ªè qua</button>
        <button class="btn ok" id="btnRoomSave">L∆∞u</button>
      </div>
    </div>
  </div>

  <script>
    const $ = (id) => document.getElementById(id);

    let __readerPreviewUrl = null;

function showReaderImage(file){
  const box = $("reader");
  if (!box || !file) return;

  // clear old preview url
  if (__readerPreviewUrl) {
    try { URL.revokeObjectURL(__readerPreviewUrl); } catch {}
    __readerPreviewUrl = null;
  }

  __readerPreviewUrl = URL.createObjectURL(file);
  box.innerHTML = `<img src="${__readerPreviewUrl}" alt="CCCD Preview" />`;
}

function clearReaderPreview(){
  const box = $("reader");
  if (!box) return;
  if (__readerPreviewUrl) {
    try { URL.revokeObjectURL(__readerPreviewUrl); } catch {}
    __readerPreviewUrl = null;
  }
  box.innerHTML = ""; // ƒë·ªÉ Html5Qrcode d√πng l·∫°i khi b·∫≠t camera
}


    function setScanStatus(html) { $("scanStatus").innerHTML = `Tr·∫°ng th√°i: ${html}`; }
    function setConvertStatus(html) { $("convertStatus").innerHTML = html; }
    function setOcrStatus(html) { $("ocrStatus").innerHTML = `OCR: ${html}`; }

    function toast(msg){
      const t = $("toast");
      t.textContent = msg;
      t.style.display = "block";
      clearTimeout(window.__toastTimer);
      window.__toastTimer = setTimeout(()=>{ t.style.display="none"; }, 1600);
    }

    function fmtDDMMYYYY(s) {
      if (!s) return "‚Äî";
      const t = ("" + s).trim();
      if (/^\d{8}$/.test(t)) return `${t.slice(0,2)}/${t.slice(2,4)}/${t.slice(4,8)}`;
      return t;
    }

    function logLine(line) {
      const box = $("log");
      if (!box) return;
      box.value = (box.value ? box.value + "\n" : "") + line;
      box.scrollTop = box.scrollHeight;
    }

    async function copyText(text){
      const v = (text || "").toString().trim();
      if (!v || v === "‚Äî") return toast("Kh√¥ng c√≥ d·ªØ li·ªáu ƒë·ªÉ copy");
      try{
        await navigator.clipboard.writeText(v);
        toast("‚úÖ ƒê√£ copy");
      }catch{
        const ta = document.createElement("textarea");
        ta.value = v;
        document.body.appendChild(ta);
        ta.select();
        document.execCommand("copy");
        document.body.removeChild(ta);
        toast("‚úÖ ƒê√£ copy");
      }
    }

    document.addEventListener("click", async (e) => {
      const btn = e.target.closest("[data-copy]");
      if (!btn) return;
      const sel = btn.getAttribute("data-copy");
      const el = document.querySelector(sel);
      await copyText(el ? el.textContent : "");
    });

    // =======================
    // ‚úÖ Tabs: QR Upload / OCR
    // =======================
    function setTab(tab){
      const isQr = tab === "qr";
      $("tabQrBtn").classList.toggle("active", isQr);
      $("tabOcrBtn").classList.toggle("active", !isQr);

      $("tabQrBtn").setAttribute("aria-selected", isQr ? "true" : "false");
      $("tabOcrBtn").setAttribute("aria-selected", !isQr ? "true" : "false");

      $("tabQrPane").classList.toggle("active", isQr);
      $("tabOcrPane").classList.toggle("active", !isQr);
    }

    $("tabQrBtn").addEventListener("click", () => setTab("qr"));
    $("tabOcrBtn").addEventListener("click", () => setTab("ocr"));

    // =======================
    // ‚úÖ B·ªô nh·ªõ t·∫°m + Export Excel
    // =======================
    const TMP_KEY = "cccd_convert_tmp_rows_v3";
    const COLS = [
      "H·ªç t√™n",
      "S·ªë CCCD",
      "Ng√†y sinh",
      "Gi·ªõi t√≠nh",
      "T·ªânh/TP",
      "X√£/Ph∆∞·ªùng/ƒê·∫∑c khu",
      "S·ªë nh√†/·∫§p/KP/ƒê∆∞·ªùng",
      "Ph√≤ng"
    ];

    function loadTmpRows(){
      try{
        const raw = sessionStorage.getItem(TMP_KEY);
        const arr = raw ? JSON.parse(raw) : [];
        return Array.isArray(arr) ? arr : [];
      }catch{ return []; }
    }

    function saveTmpRows(rows){
      try{ sessionStorage.setItem(TMP_KEY, JSON.stringify(rows || [])); }catch{}
      renderSavedCount();
      renderTmpTable();
    }

    function renderSavedCount(){
      const rows = loadTmpRows();
      $("savedCount").textContent = String(rows.length);
    }

    function normalizeCell(v){
      const s = (v ?? "").toString().trim();
      return (s === "‚Äî") ? "" : s;
    }

    function buildRowFromUI(roomValue){
      const row = {
        "H·ªç t√™n": normalizeCell($("name").textContent),
        "S·ªë CCCD": normalizeCell($("cccd").textContent),
        "Ng√†y sinh": normalizeCell($("dob").textContent),
        "Gi·ªõi t√≠nh": normalizeCell($("gender").textContent),
        "T·ªânh/TP": normalizeCell($("addrProvince").textContent),
        "X√£/Ph∆∞·ªùng/ƒê·∫∑c khu": normalizeCell($("addrWard").textContent),
        "S·ªë nh√†/·∫§p/KP/ƒê∆∞·ªùng": normalizeCell($("addrStreet").textContent),
        "Ph√≤ng": normalizeCell(roomValue || "")
      };

      if (!row["S·ªë CCCD"] || !row["H·ªç t√™n"]) {
        throw new Error("Ch∆∞a c√≥ d·ªØ li·ªáu CCCD/H·ªç t√™n ƒë·ªÉ l∆∞u. H√£y qu√©t/parse/OCR tr∆∞·ªõc.");
      }
      if (!row["T·ªânh/TP"] || !row["X√£/Ph∆∞·ªùng/ƒê·∫∑c khu"]) {
        throw new Error("Ch∆∞a c√≥ ƒë·ªãa ch·ªâ m·ªõi. H√£y chuy·ªÉn ƒë·ªïi ƒë·ªãa ch·ªâ tr∆∞·ªõc r·ªìi h√£y l∆∞u.");
      }
      return row;
    }

    function downloadBlob(filename, blob){
      const a = document.createElement("a");
      a.href = URL.createObjectURL(blob);
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      setTimeout(() => {
        URL.revokeObjectURL(a.href);
        document.body.removeChild(a);
      }, 0);
    }

    function toCsv(rows){
      const esc = (v) => {
        const s = (v ?? "").toString();
        const needs = /[",\n\r]/.test(s);
        const out = s.replace(/"/g, '""');
        return needs ? `"${out}"` : out;
      };
      const head = COLS.map(esc).join(",");
      const body = rows.map(r => COLS.map(c => esc(r?.[c] ?? "")).join(",")).join("\n");
      return "\ufeff" + head + "\n" + body;
    }

    function exportExcel(){
      const rows = loadTmpRows();
      if (!rows.length) return toast("Ch∆∞a c√≥ d√≤ng n√†o trong b·∫£ng t·∫°m ƒë·ªÉ xu·∫•t.");

      const today = new Date();
      const yyyy = today.getFullYear();
      const mm = String(today.getMonth() + 1).padStart(2, "0");
      const dd = String(today.getDate()).padStart(2, "0");
      const filenameXlsx = `CCCD_DiaChi_${yyyy}-${mm}-${dd}.xlsx`;
      const filenameCsv  = `CCCD_DiaChi_${yyyy}-${mm}-${dd}.csv`;

      if (window.XLSX && window.XLSX.utils) {
        const ordered = rows.map(r => {
          const o = {};
          COLS.forEach(c => o[c] = r?.[c] ?? "");
          return o;
        });

        const ws = XLSX.utils.json_to_sheet(ordered, { header: COLS });
        ws["!cols"] = [
          { wch: 24 },
          { wch: 18 },
          { wch: 14 },
          { wch: 10 },
          { wch: 18 },
          { wch: 26 },
          { wch: 42 },
          { wch: 10 },
        ];

        const wb = XLSX.utils.book_new();
        XLSX.utils.book_append_sheet(wb, ws, "DanhSach");
        XLSX.writeFile(wb, filenameXlsx);
        toast("‚úÖ ƒê√£ xu·∫•t Excel");
        return;
      }

      const csv = toCsv(rows);
      downloadBlob(filenameCsv, new Blob([csv], { type: "text/csv;charset=utf-8" }));
      toast("‚úÖ ƒê√£ xu·∫•t CSV (m·ªü b·∫±ng Excel)");
    }

    function renderTmpTable(){
      const rows = loadTmpRows();
      const empty = $("tmpEmpty");
      const table = $("tmpTable");
      const head = $("tmpHead");
      const body = $("tmpBody");

      if (!rows.length){
        empty.style.display = "block";
        table.style.display = "none";
        body.innerHTML = "";
        head.innerHTML = "";
        return;
      }

      empty.style.display = "none";
      table.style.display = "table";

      head.innerHTML = "";
      const th0 = document.createElement("th");
      th0.textContent = "#";
      head.appendChild(th0);

      COLS.forEach(c => {
        const th = document.createElement("th");
        th.textContent = c;
        head.appendChild(th);
      });

      const thAct = document.createElement("th");
      thAct.textContent = "H√†nh ƒë·ªông";
      head.appendChild(thAct);

      body.innerHTML = "";
      rows.forEach((r, idx) => {
        const tr = document.createElement("tr");

        const tdIndex = document.createElement("td");
        tdIndex.textContent = String(idx + 1);
        tdIndex.setAttribute("data-label", "#");
        tr.appendChild(tdIndex);

        COLS.forEach(c => {
          const td = document.createElement("td");
          td.textContent = (r?.[c] ?? "");
          td.setAttribute("data-label", c);
          tr.appendChild(td);
        });

        const tdAct = document.createElement("td");
        tdAct.style.whiteSpace = "nowrap";
        tdAct.setAttribute("data-label", "H√†nh ƒë·ªông");

        const del = document.createElement("button");
        del.className = "miniBtn danger";
        del.textContent = "X√≥a";
        del.addEventListener("click", () => {
          const cur = loadTmpRows();
          cur.splice(idx, 1);
          saveTmpRows(cur);
          toast("‚úÖ ƒê√£ x√≥a d√≤ng");
        });

        const tele = document.createElement("button");
        tele.className = "miniBtn";
        tele.textContent = "Tele";
        tele.style.marginRight = "8px";

        tele.addEventListener("click", async () => {
          try{
            toast("‚è≥ ƒêang g·ª≠i Telegram...");
            await sendTelegramMessage(buildTelegramMessageFromRow(r));
            toast("‚úÖ ƒê√£ g·ª≠i Telegram");
          }catch(e){
            toast("‚ùå " + (e?.message || e));
          }
        });

        tdAct.appendChild(tele);

        tdAct.appendChild(del);
        tr.appendChild(tdAct);

        body.appendChild(tr);
      });
    }

    // =======================
    // ‚úÖ Popup nh·∫≠p ph√≤ng khi l∆∞u t·∫°m
    // =======================
    function openRoomModal(){
      $("roomModalInput").value = "";
      $("roomModal").style.display = "flex";
      setTimeout(() => $("roomModalInput").focus(), 0);
    }
    function closeRoomModal(){
      $("roomModal").style.display = "none";
    }

    let __roomModalPurpose = "save"; // "save" | "telegram"

    function openRoomModalFor(purpose){
      __roomModalPurpose = purpose || "save";
      $("roomModalTitle").textContent = (purpose === "telegram")
        ? "Nh·∫≠p s·ªë ph√≤ng ƒë·ªÉ g·ª≠i Telegram"
        : "Nh·∫≠p s·ªë ph√≤ng (t√πy ch·ªçn)";

      // c√≥ th·ªÉ ƒë·ªïi m√¥ t·∫£ lu√¥n n·∫øu mu·ªën
      // $("roomModalSub").textContent = ...

      $("roomModalInput").value = "";
      $("roomModal").style.display = "flex";
      setTimeout(() => $("roomModalInput").focus(), 0);
    }

    $("roomModal").addEventListener("click", (e) => {
      if (e.target === $("roomModal")) closeRoomModal();
    });

    $("btnCloseRoomModal").addEventListener("click", closeRoomModal);
    $("btnRoomCancel").addEventListener("click", closeRoomModal);

    function doSaveTmpWithRoom(roomVal){
      const row = buildRowFromUI(roomVal);
      const rows = loadTmpRows();
      rows.push(row);
      saveTmpRows(rows);
    }

$("btnRoomSave").addEventListener("click", async () => {
  try{
    const roomVal = $("roomModalInput").value;

    if (__roomModalPurpose === "telegram") {
      closeRoomModal();
      if (__pendingTelegramSend) await __pendingTelegramSend(roomVal);
      return;
    }

    // m·∫∑c ƒë·ªãnh: save tmp
    doSaveTmpWithRoom(roomVal);
    closeRoomModal();
    toast("‚úÖ ƒê√£ l∆∞u v√†o b·∫£ng t·∫°m");
  }catch(e){
    toast("‚ùå " + e.message);
  }
});

$("btnRoomSkip").addEventListener("click", async () => {
  try{
    if (__roomModalPurpose === "telegram") {
      closeRoomModal();
      if (__pendingTelegramSend) await __pendingTelegramSend("");
      return;
    }

    // m·∫∑c ƒë·ªãnh: save tmp
    doSaveTmpWithRoom("");
    closeRoomModal();
    toast("‚úÖ ƒê√£ l∆∞u (kh√¥ng c√≥ ph√≤ng)");
  }catch(e){
    toast("‚ùå " + e.message);
  }
});



    // =======================
    // ‚úÖ QR parse (ƒëa ƒë·ªãnh d·∫°ng)
    // =======================
    function normalizeQR(raw) {
      return (raw || "")
        .toString()
        .trim()
        .replace(/\r\n/g, "\n")
        .replace(/\|\s*---\s*\|/g, "|");
    }

    function parseQRFromPipes(raw) {
      const s = normalizeQR(raw);
      const parts = s.split("|").map(x => (x || "").trim()).filter(x => x.length > 0);
      if (parts.length < 6) throw new Error("Chu·ªói QR kh√¥ng ƒë√∫ng ƒë·ªãnh d·∫°ng (c·∫ßn t·ªëi thi·ªÉu 6 tr∆∞·ªùng).");
      return { cccd: parts[0], name: parts[1], dob: parts[2], gender: parts[3], address: parts[4], issue: parts[5] };
    }

    function parseQRFromLabeledText(raw) {
      const s = normalizeQR(raw);

      const pick = (patterns) => {
        for (const re of patterns) {
          const m = s.match(re);
          if (m && m[1]) return (m[1] || "").trim();
        }
        return "";
      };

      const cccd = pick([
        /S·ªë\s*CCCD\s*:\s*([0-9]{9,20})/i,
        /\bCCCD\s*:\s*([0-9]{9,20})/i,
        /\bS·ªë\s*:\s*([0-9]{9,20})/i,
      ]);

      const name = pick([
        /H·ªç\s*(?:v√†\s*)?t√™n\s*:\s*([^\n\r]+)/i,
        /H·ªç\s*t√™n\s*:\s*([^\n\r]+)/i,
      ]);

      const gender = pick([
        /Gi·ªõi\s*t√≠nh\s*:\s*([^\n\r]+)/i,
        /Sex\s*:\s*([^\n\r]+)/i,
      ]);

      const dob = pick([
        /Ng√†y\s*sinh\s*:\s*([0-9]{1,2}[\/\-.][0-9]{1,2}[\/\-.][0-9]{2,4}|\d{8})/i,
        /Sinh\s*ng√†y\s*:\s*([0-9]{1,2}[\/\-.][0-9]{1,2}[\/\-.][0-9]{2,4}|\d{8})/i,
      ]);

      const address = pick([
        /N∆°i\s*th∆∞·ªùng\s*tr√∫\s*:\s*([^\n\r]+)/i,
        /ƒê·ªãa\s*ch·ªâ\s*(?:th∆∞·ªùng\s*tr√∫)?\s*:\s*([^\n\r]+)/i,
        /Address\s*:\s*([^\n\r]+)/i,
      ]);

      const issue = pick([
        /Ng√†y\s*c·∫•p(?:\s*CCCD)?\s*:\s*([0-9]{1,2}[\/\-.][0-9]{1,2}[\/\-.][0-9]{2,4}|\d{8})/i,
      ]);

      const ok = (cccd && name && dob && gender && address && issue);
      if (!ok) {
        throw new Error("Kh√¥ng ƒë·ªçc ƒë·ªß tr∆∞·ªùng t·ª´ d·∫°ng 'c√≥ nh√£n'. C·∫ßn: S·ªë CCCD, H·ªç v√† t√™n, Gi·ªõi t√≠nh, Ng√†y sinh, N∆°i th∆∞·ªùng tr√∫, Ng√†y c·∫•p CCCD.");
      }

      return { cccd, name, dob, gender, address, issue };
    }

    function parseQRAny(raw) {
      const s = normalizeQR(raw);

      if (s.includes("|")) return parseQRFromPipes(s);

      if (/S·ªë\s*CCCD\s*:|H·ªç\s*(?:v√†\s*)?t√™n\s*:|N∆°i\s*th∆∞·ªùng\s*tr√∫\s*:/i.test(s)) {
        return parseQRFromLabeledText(s);
      }

      throw new Error("Chu·ªói kh√¥ng ƒë√∫ng ƒë·ªãnh d·∫°ng. D√°n d·∫°ng '|' ho·∫∑c d·∫°ng nhi·ªÅu d√≤ng c√≥ nh√£n.");
    }

    function fillInfo(data) {
      $("cccd").textContent = data?.cccd || "‚Äî";
      $("name").textContent = data?.name || "‚Äî";
      $("dob").textContent = fmtDDMMYYYY(data?.dob);
      $("gender").textContent = data?.gender || "‚Äî";
      $("oldAddr").textContent = data?.address || "‚Äî";
      $("issue").textContent = fmtDDMMYYYY(data?.issue);
    }

    function setNewAddressFields({full, province, ward, street}){
      $("addrFull").textContent = full || "‚Äî";
      $("addrProvince").textContent = province || "‚Äî";
      $("addrWard").textContent = ward || "‚Äî";
      $("addrStreet").textContent = street || "‚Äî";
    }

    function splitFullAddress(full){
      const chunks = (full || "").split(",").map(s => s.trim()).filter(Boolean);
      if (chunks.length === 0) return { full:"", province:"", ward:"", street:"" };
      if (chunks.length === 1) return { full, province:"", ward:"", street: chunks[0] };

      const provinceRaw = chunks[chunks.length - 1] || "";
      const wardRaw = chunks.length >= 2 ? chunks[chunks.length - 2] : "";
      const street = chunks.slice(0, Math.max(0, chunks.length - 2)).join(", ").trim();

      const province = stripAdminPrefix(provinceRaw, "province");
      const ward = stripAdminPrefix(wardRaw, "ward");

      return { full, province, ward, street };
    }

    // =======================
    // ‚úÖ Address helpers for code guessing
    // =======================
    function stripDiacritics(s) {
      return (s || "")
        .normalize("NFD")
        .replace(/[\u0300-\u036f]/g, "")
        .replace(/ƒë/g, "d")
        .replace(/ƒê/g, "D");
    }

    function normalizeNumberName(s){
      const t = (s || "").toString().trim();
      if (/^\d+$/.test(t)) return String(parseInt(t, 10));
      return t;
    }

    function stripAdminPrefix(text, type){
  let s = (text || "").trim();
  if (!s) return s;

  // ‚úÖ Fix l·ªói "Ph∆∞∆°ÃÄng" (Unicode t·ªï h·ª£p) kh√¥ng match ƒë∆∞·ª£c "ph∆∞·ªùng"
  s = s.normalize("NFC");

  if (type === "province") {
    s = s.replace(/^(t·ªânh|th√†nh ph·ªë|tp\.?|t\.p\.?)\s+/i, "");
    s = s.replace(/^(city|province)\s+/i, "");
    return s.trim();
  }

  if (type === "district") {
    // ‚úÖ q ch·ªâ ƒë∆∞·ª£c ph√©p match khi sau q l√† "." ho·∫∑c space/digit (Q.1, Q 1, Q1)
    s = s.replace(/^q\.?(?=\s|\d)/i, "");
    s = s.replace(/^(qu·∫≠n|huy·ªán|th√†nh ph·ªë|tp\.?|t\.p\.?|th·ªã x√£|tx\.?|ƒë·∫∑c khu)\s+/i, "");
    s = s.replace(/^(district|city|town|township)\s+/i, "");
    return s.trim();
  }

  if (type === "ward") {
    // ‚úÖ p ch·ªâ match khi sau p l√† "." ho·∫∑c space/digit (P.02, P 02, P02) ‚Äî kh√¥ng ƒÉn "Ph∆∞·ªùng"
    s = s.replace(/^p\.?(?=\s|\d)/i, "");

    s = s.replace(/^(x√£|x\.?|ph∆∞·ªùng|th·ªã tr·∫•n|tt\.?|ƒë·∫∑c khu)\s*/i, "");
    s = s.replace(/^(commune|ward|townlet)\s+/i, "");
    return s.trim();
  }

  return s.trim();
}


    function detectTypeHint(raw, kind){
      const s = stripDiacritics((raw || "").toLowerCase());

      if (kind === "district") {
        if (/\b(quan|q\.)\b/.test(s) || s.includes(" quan ")) return "Qu·∫≠n";
        if (/\b(huyen|h\.)\b/.test(s) || s.includes(" huyen ")) return "Huy·ªán";
        if (/\b(thi xa|tx\.)\b/.test(s) || s.includes(" thi xa ")) return "Th·ªã x√£";
        if (/\b(tp|thanh pho|t\.p\.)\b/.test(s) || s.includes(" thanh pho ")) return "Th√†nh ph·ªë";
        if (s.includes(" dac khu ")) return "ƒê·∫∑c khu";
        return "";
      }

      if (kind === "ward") {
        if (/\b(phuong|p\.)\b/.test(s) || s.includes(" phuong ")) return "Ph∆∞·ªùng";
        if (/\b(xa|x\.)\b/.test(s) || s.includes(" xa ")) return "X√£";
        if (s.includes(" thi tran ") || s.includes(" tt.")) return "Th·ªã tr·∫•n";
        if (s.includes(" dac khu ")) return "ƒê·∫∑c khu";
        return "";
      }

      if (kind === "province") {
        if (/\b(tp|thanh pho|t\.p\.)\b/.test(s) || s.includes(" thanh pho ")) return "Th√†nh ph·ªë";
        if (s.includes(" tinh ")) return "T·ªânh";
        return "";
      }

      return "";
    }

function normName(s) {
  return stripDiacritics((s || "").toString().normalize("NFC")).toLowerCase()
    .replace(/\b(thanh pho|thi xa|quan|q\.|huyen|h\.|thi tran|xa|x\.|phuong|p\.|tp|t\.p\.|tx\.|dac khu)\b/g, " ")
    .replace(/[^\w\s]/g, " ")
    .replace(/\s+/g, " ")
    .trim();
}


    function bestMatch(list, rawName, typeHint){
      if (!list?.length) return null;

      const cleanedRaw = (rawName || "").toString().trim();
      const cleaned = normName(cleanedRaw);

      let candidates = list.filter(x => normName(x.name) === cleaned);
      if (!candidates.length) {
        candidates = list.filter(x => {
          const n = normName(x.name);
          return n.includes(cleaned) || cleaned.includes(n);
        });
      }

      if (!candidates.length) return null;

      if (typeHint) {
        const typed = candidates.filter(x => (x.type || "").toLowerCase().includes(typeHint.toLowerCase()));
        if (typed.length) return typed[0];
      }

      if (candidates.length > 1) {
        logLine(`‚ö†Ô∏è Tr√πng t√™n "${cleanedRaw}". Candidates=` +
          candidates.map(c => `${c.type} ${c.name}(${c.code})`).join(" | ")
        );
      }
      return candidates[0];
    }

    function normalizeWardDisplayName(rawWard){
      const s = stripAdminPrefix(rawWard, "ward");
      return normalizeNumberName(s);
    }

    function splitAddress(addr) {
      const chunks = (addr || "").trim().split(",").map(x => x.trim()).filter(Boolean);
      if (chunks.length < 3) {
        return { street: (addr || "").trim(), wardName:"", districtName:"", provinceName:"", wardHint:"", districtHint:"", provinceHint:"" };
      }

      const provinceRaw = chunks[chunks.length - 1];
      const districtRaw = chunks[chunks.length - 2];
      const wardRaw = chunks[chunks.length - 3];
      const street = chunks.slice(0, -3).join(", ").trim();

      const provinceHint = detectTypeHint(provinceRaw, "province");
      const districtHint = detectTypeHint(districtRaw, "district");
      const wardHint = detectTypeHint(wardRaw, "ward");

      const provinceName = stripAdminPrefix(provinceRaw, "province");
      const districtName = stripAdminPrefix(districtRaw, "district");
      const wardName = normalizeWardDisplayName(wardRaw);

      return { street, wardName, districtName, provinceName, wardHint, districtHint, provinceHint };
    }

    // =======================
    // ‚úÖ API tinhthanhpho
    // =======================
    const BASE = "https://tinhthanhpho.com/api/v1";

    async function apiGET(path, params) {
      const url = new URL(BASE + path);
      Object.entries(params || {}).forEach(([k,v]) => {
        if (v !== undefined && v !== null && (""+v).length > 0) url.searchParams.set(k, v);
      });

      logLine("GET " + url.toString());
      const res = await fetch(url.toString(), { headers: { "Accept": "application/json" }});
      const data = await res.json().catch(() => ({}));
      logLine("‚Ü≥ " + res.status + " " + JSON.stringify(data).slice(0, 1200));

      if (!res.ok) throw new Error(`GET ${path} l·ªói HTTP ${res.status}`);
      if (data && data.success === false) throw new Error(data.message || "API success=false");
      return data;
    }

    async function apiPOST(path, body, apiKey) {
      const url = BASE + path;
      logLine("POST " + url);
      logLine("Body: " + JSON.stringify(body));

      const res = await fetch(url, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Accept": "application/json",
          "Authorization": "Bearer " + apiKey
        },
        body: JSON.stringify(body)
      });
      const data = await res.json().catch(() => ({}));
      logLine("‚Ü≥ " + res.status + " " + JSON.stringify(data).slice(0, 1600));

      if (!res.ok) throw new Error(`POST ${path} l·ªói HTTP ${res.status}` + (data?.message ? `: ${data.message}` : ""));
      if (data && data.success === false) throw new Error(data.message || "API success=false");
      return data;
    }

    async function findProvince(provinceName) {
      const res = await apiGET("/provinces", { keyword: provinceName, limit: 20, page: 1 });
      const list = res.data || [];
      if (!list.length) throw new Error("Kh√¥ng t√¨m th·∫•y t·ªânh: " + provinceName);
      return bestMatch(list, provinceName, detectTypeHint(provinceName, "province")) || list[0];
    }

    // ‚úÖ FIX: TR√ôNG T√äN district (VD Cao L√£nh c√≥ c·∫£ TP + Huy·ªán)
    async function findDistrictInProvince(provinceCode, districtRaw) {
      const res = await apiGET(`/provinces/${encodeURIComponent(provinceCode)}/districts`, { limit: 500, page: 1 });
      const list = res.data || [];
      if (!list.length) throw new Error("API tr·∫£ 0 districts cho province=" + provinceCode);

      const hint = detectTypeHint(districtRaw, "district");
      const cleanName = stripAdminPrefix(districtRaw, "district");

      let d = bestMatch(list, cleanName, hint);

      if (!d && /thi xa/i.test(stripDiacritics(districtRaw))) {
        d = bestMatch(list, cleanName, "Th·ªã x√£") || bestMatch(list, cleanName, "Th√†nh ph·ªë");
      }

      if (!d?.code) throw new Error("Kh√¥ng match ƒë∆∞·ª£c district: " + districtRaw);

      logLine(`‚úÖ Pick district: ${d.type} ${d.name} (${d.code}) [hint=${hint||"none"}]`);
      return d;
    }

    // ‚úÖ FIX: ward d·∫°ng s·ªë "02" / "P.02" / "Ph∆∞·ªùng 02" -> "2"
    async function findWardInDistrict(districtCode, wardRaw) {
      const res = await apiGET(`/districts/${encodeURIComponent(districtCode)}/wards`, { limit: 1000, page: 1 });
      const list = res.data || [];
      if (!list.length) throw new Error("API tr·∫£ 0 wards cho district=" + districtCode);

      const hint = detectTypeHint(wardRaw, "ward");
      const cleanName = normalizeWardDisplayName(wardRaw);

      let w = bestMatch(list, cleanName, hint);
      if (!w) w = bestMatch(list, stripAdminPrefix(wardRaw, "ward"), hint);

      if (!w?.code) throw new Error("Kh√¥ng match ƒë∆∞·ª£c ward: " + wardRaw);

      logLine(`‚úÖ Pick ward: ${w.type} ${w.name} (${w.code}) [hint=${hint||"none"}]`);
      return w;
    }

    async function guessCodesFromAddress(addr) {
      const { street, wardName, districtName, provinceName, wardHint, districtHint } = splitAddress(addr);

      if (!provinceName || !districtName || !wardName) {
        throw new Error("Kh√¥ng t√°ch ƒë∆∞·ª£c t·ªânh/huy·ªán/x√£ (c·∫ßn 3 c·ª•m cu·ªëi c√°ch nhau b·ªüi d·∫•u ph·∫©y).");
      }

      setConvertStatus(`ƒêang d√≤ m√£: <b>${provinceName}</b> / <b>${districtName}</b> / <b>${wardName}</b> ...`);

      const prov = await findProvince(provinceName);

      const districtRawForMatch = (districtHint ? `${districtHint} ${districtName}` : districtName);
      const dist = await findDistrictInProvince(prov.code, districtRawForMatch);

      const wardRawForMatch = (wardHint ? `${wardHint} ${wardName}` : wardName);
      const ward = await findWardInDistrict(dist.code, wardRawForMatch);

      $("provinceCode").value = prov.code;
      $("districtCode").value = dist.code;
      $("wardCode").value = ward.code;
      $("streetAddress").value = street || "";

      return { provinceCode: prov.code, districtCode: dist.code, wardCode: ward.code, streetAddress: street || "" };
    }

    // =======================
    // ‚úÖ Scanner + auto convert flow
    // =======================
    let qr = null;
    let currentData = null;

    let converting = false;
    let lastQrText = "";
    let lastConvertAt = 0;

    async function autoConvertNow(){
      const apiKey = ($("apiKey").value || "").trim();
      if (!apiKey) {
        setConvertStatus(`<span class="warn">Ch∆∞a c√≥ API key.</span> Nh·∫≠p API key ƒë·ªÉ t·ª± chuy·ªÉn ƒë·ªïi sau khi c√≥ d·ªØ li·ªáu.`);
        return;
      }
      if (!currentData?.address) {
        setConvertStatus(`<span class="warn">Ch∆∞a c√≥ ƒë·ªãa ch·ªâ c≈© ƒë·ªÉ chuy·ªÉn ƒë·ªïi.</span>`);
        return;
      }

      const now = Date.now();
      if (converting) return;
      if (now - lastConvertAt < 800) return;
      converting = true;
      lastConvertAt = now;

      try{
        if ($("log")) $("log").value = "";
        setNewAddressFields({full:"‚Äî", province:"‚Äî", ward:"‚Äî", street:"‚Äî"});

        let payload;
        if ($("mode").value === "manual") {
          const provinceCode = ($("provinceCode").value || "").trim();
          const districtCode = ($("districtCode").value || "").trim();
          const wardCode = ($("wardCode").value || "").trim();
          const streetAddress = ($("streetAddress").value || "").trim();
          if (!provinceCode || !districtCode || !wardCode) throw new Error("Thi·∫øu m√£ province/district/ward (mode manual).");
          payload = { provinceCode, districtCode, wardCode, streetAddress };
        } else {
          payload = await guessCodesFromAddress(currentData.address);
        }

        setConvertStatus("<b>ƒêang g·ªçi API chuy·ªÉn ƒë·ªïi...</b>");
        const res = await apiPOST("/convert/address", payload, apiKey);

        const newFull = res?.data?.new?.fullAddress || "";
        const notes = res?.data?.mergeInfo?.notes || "";

        if (!newFull) {
          setConvertStatus(`<span class="warn">C√≥ ph·∫£n h·ªìi nh∆∞ng kh√¥ng th·∫•y new.fullAddress.</span> Xem log ƒë·ªÉ debug.`);
          return;
        }

        const parts = splitFullAddress(newFull);
        setNewAddressFields(parts);

        setConvertStatus(
          `<span class="oktxt">Th√†nh c√¥ng!</span> ` +
          (notes ? `<span class="small">Ghi ch√∫: ${notes}</span>` : "")
        );
      }catch(e){
        setConvertStatus(`<span class="error">L·ªói:</span> ${e.message}`);
      }finally{
        converting = false;
      }
    }

    async function onScanSuccess(decodedText) {
      const text = (decodedText || "").trim();
      if (!text) return;
      if (text === lastQrText) return;
      lastQrText = text;

      try {
        setScanStatus(`<b class="oktxt">ƒê√£ qu√©t</b>`);
        $("rawInput").value = text;

        const data = parseQRAny(text);
        currentData = data;
        fillInfo(data);

        await stopScanner();
        await autoConvertNow();
      } catch (e) {
        setScanStatus(`<b class="error">L·ªói</b> ‚Ä¢ ${e.message}`);
      }
    }

    async function startScanner() {
      if (typeof window.Html5Qrcode === "undefined") {
        setScanStatus(`<b class="error">Kh√¥ng load ƒë∆∞·ª£c Html5Qrcode</b> ‚Ä¢ Ki·ªÉm tra ƒë∆∞·ªùng d·∫´n script local.`);
        return;
      }
      if (!qr) qr = new Html5Qrcode("reader");

      $("btnStart").disabled = true;
      $("btnStop").disabled = false;
      setScanStatus("<b>ƒêang m·ªü camera...</b>");

      try {
        lastQrText = "";

        await qr.start(
          { facingMode: { ideal: "environment" } },
          {
            fps: 60,
            qrbox: (vw, vh) => {
              const s = Math.floor(Math.min(vw, vh) * 0.88);
              return { width: s, height: s };
            },
            disableFlip: true,
            videoConstraints: {
              facingMode: { ideal: "environment" },
              width: { ideal: 2560 },
              height: { ideal: 1440 },
              advanced: [
                { focusMode: "continuous" },
                { zoom: 3 }
              ]
            },
            showTorchButtonIfSupported: true,
            showZoomSliderIfSupported: true,
            defaultZoomValueIfSupported: 2,
            experimentalFeatures: { useBarCodeDetectorIfSupported: true },
          },
          onScanSuccess,
          (err) => {}
        );

        setScanStatus("<b class='oktxt'>ƒêang qu√©t...</b> ƒê∆∞a QR v√†o khung (th·ª≠ zoom 2x‚Äì3x n·∫øu c√≥).");
      } catch (e) {
        $("btnStart").disabled = false;
        $("btnStop").disabled = true;
        setScanStatus(`<b class="error">Kh√¥ng m·ªü ƒë∆∞·ª£c camera</b> ‚Ä¢ ${e.message}`);
      }
    }

    async function stopScanner() {
      if (!qr) return;
      try { await qr.stop(); await qr.clear(); } catch {}
      $("btnStart").disabled = false;
      $("btnStop").disabled = true;
      setScanStatus("<b>ƒê√£ d·ª´ng</b>");
    }

    $("btnStart").addEventListener("click", startScanner);
    $("btnStop").addEventListener("click", stopScanner);

    $("btnClear").addEventListener("click", () => {
      $("rawInput").value = "";
      $("log").value = "";
      currentData = null;
      lastQrText = "";
      fillInfo({});
      setNewAddressFields({full:"‚Äî", province:"‚Äî", ward:"‚Äî", street:"‚Äî"});
      setScanStatus("<b>Ch∆∞a qu√©t</b>");
      setConvertStatus("‚Äî");

      // OCR reset
      window.__idFile = null;
      $("idFile").value = "";
      $("btnOcrId").disabled = true;
      $("btnOcrClear").disabled = true;
      setOcrStatus("‚Äî");
      // N·∫øu mu·ªën reset tab v·ªÅ QR:
      // setTab("qr");
    });

    $("btnParse").addEventListener("click", async () => {
      try {
        const data = parseQRAny($("rawInput").value);
        currentData = data;
        fillInfo(data);
        setConvertStatus(`<span class="oktxt">Parse OK.</span> ƒêang t·ª± chuy·ªÉn ƒë·ªïi...`);
        await autoConvertNow();
      } catch (e) {
        setConvertStatus(`<span class="error">L·ªói:</span> ${e.message}`);
      }
    });

    $("mode").addEventListener("change", (e) => {
      $("manualCodes").style.display = (e.target.value === "manual") ? "grid" : "none";
    });

    $("apiKey").addEventListener("change", async () => {
      if (currentData?.address) await autoConvertNow();
    });

    $("btnCopyAll").addEventListener("click", async () => {
      const all =
`CCCD: ${$("cccd").textContent}
H·ªç t√™n: ${$("name").textContent}
Ng√†y sinh: ${$("dob").textContent}
Gi·ªõi t√≠nh: ${$("gender").textContent}
ƒê·ªãa ch·ªâ c≈©: ${$("oldAddr").textContent}
Ng√†y c·∫•p: ${$("issue").textContent}

ƒê·ªäA CH·ªà M·ªöI (T·ªîNG): ${$("addrFull").textContent}
T·ªânh/TP: ${$("addrProvince").textContent}
X√£/Ph∆∞·ªùng/ƒê·∫∑c khu: ${$("addrWard").textContent}
S·ªë nh√†/·∫§p/KP/ƒê∆∞·ªùng: ${$("addrStreet").textContent}
`.trim();

      await copyText(all);
    });

    // ‚úÖ L∆∞u t·∫°m -> m·ªü popup nh·∫≠p ph√≤ng (c√≥ th·ªÉ b·ªè qua)
    $("btnSaveTmp").addEventListener("click", () => {
      try{
        buildRowFromUI(""); // validate
        openRoomModal();
      }catch(e){
        toast("‚ùå " + e.message);
      }
    });

// =======================
// ‚úÖ ƒêi·ªÅn CT01 & chuy·ªÉn trang
// =======================
const CT01_PREFILL_KEY = "ct01_prefill_v1";

function todayDDMMYYYY(){
  const d = new Date();
  const dd = String(d.getDate()).padStart(2,"0");
  const mm = String(d.getMonth()+1).padStart(2,"0");
  const yyyy = d.getFullYear();
  return `${dd}/${mm}/${yyyy}`;
}

function buildCT01Prefill(){
  const fullName = ($("name")?.textContent || "").trim();
  const idNumber = ($("cccd")?.textContent || "").trim();
  const dob = ($("dob")?.textContent || "").trim();
  const gender = ($("gender")?.textContent || "").trim();

  // ∆Øu ti√™n ƒë·ªãa ch·ªâ m·ªõi (ƒë·ªãa ch·ªâ t·ªïng), fallback ƒë·ªãa ch·ªâ c≈©
  const newFull = ($("addrFull")?.textContent || "").trim();
  const oldAddr = ($("oldAddr")?.textContent || "").trim();



  const tempAddress = (newFull && newFull !== "‚Äî") ? newFull : ((oldAddr && oldAddr !== "‚Äî") ? oldAddr : "");

  // N·∫øu kh√¥ng c√≥ ƒë·ªß d·ªØ li·ªáu c∆° b·∫£n th√¨ b√°o
  if (!fullName || fullName === "‚Äî" || !idNumber || idNumber === "‚Äî"){
    throw new Error("Ch∆∞a c√≥ H·ªç t√™n/CCCD. H√£y qu√©t/parse/OCR tr∆∞·ªõc.");
  }
  if (!tempAddress){
    // v·∫´n cho qua n·∫øu b·∫°n mu·ªën, nh∆∞ng th∆∞·ªùng CT01 c·∫ßn ƒë·ªãa ch·ªâ
    // throw new Error("Ch∆∞a c√≥ ƒë·ªãa ch·ªâ ƒë·ªÉ ƒëi·ªÅn CT01.");
  }

  // ƒê·∫©y theo ƒë√∫ng schema state c·ªßa ct01.html m√¨nh g·ª≠i tr∆∞·ªõc ƒë√≥
  return {
    agency: "C√¥ng an ph∆∞·ªùng B√¨nh C∆°, TP. H·ªì Ch√≠ Minh",

    fullName,
    dob: (dob && dob !== "‚Äî") ? dob : "",
    gender: (gender && gender !== "‚Äî") ? gender : "",

    idNumber: idNumber.replace(/\D/g, "").slice(0, 12),

    phone: "",
    email: "",

    householdHeadName: "",
    relationToHead: "",
    headIdNumber: "",

    requestType: "tamtru",

    relationToHead: "Ng∆∞·ªùi Thu√™ Tr·ªç",

    tempAddress: tempAddress || "",
    fromDate: todayDDMMYYYY(),
    toDate: "",
    reason: "Thu√™ tr·ªç",

    // ƒë·ªÉ ct01 t·ª± build n·∫øu b·∫°n c√≥ logic buildSuggestedContent,
    // nh∆∞ng m√¨nh v·∫´n set s·∫µn n·ªôi dung ƒë∆°n gi·∫£n:
    requestContent: tempAddress
      ? `ƒê·ªÅ ngh·ªã ƒëƒÉng k√Ω t·∫°m tr√∫ t·∫°i: ${tempAddress}. Th·ªùi gian t·∫°m tr√∫: t·ª´ ng√†y ${todayDDMMYYYY()}. L√Ω do: Thu√™ tr·ªç.`
      : `ƒê·ªÅ ngh·ªã ƒëƒÉng k√Ω t·∫°m tr√∫. Th·ªùi gian t·∫°m tr√∫: t·ª´ ng√†y ${todayDDMMYYYY()}. L√Ω do: Thu√™ tr·ªç.`,

    members: [],

    declareDate: todayDDMMYYYY(),
    place: "TP. H·ªì Ch√≠ Minh",

    sigHead: "",
    sigOwner: "",
    sigGuardian: "",
    sigDeclarer: fullName,
    extraNote: "T·∫°o t·ª´ trang qu√©t QR"
  };
}

$("btnGoCT01").addEventListener("click", () => {
  try{
    const prefill = buildCT01Prefill();
    sessionStorage.setItem(CT01_PREFILL_KEY, JSON.stringify(prefill));
    // chuy·ªÉn qua ct01.html (ƒë·ªïi ƒë√∫ng t√™n file c·ªßa b·∫°n)
    window.location.href = "./ct01.html";
  }catch(e){
    toast("‚ùå " + (e?.message || e));
  }
});
function sleep(ms){ return new Promise(res => setTimeout(res, ms)); }

$("btnSendTelegramTmpAll").addEventListener("click", async () => {
  const rows = loadTmpRows();
  if (!rows.length) return toast("B·∫£ng t·∫°m ƒëang tr·ªëng.");

  if (!confirm(`G·ª≠i Telegram cho ${rows.length} d√≤ng?`)) return;

  try{
    for (let i = 0; i < rows.length; i++){
      toast(`‚è≥ ƒêang g·ª≠i ${i+1}/${rows.length}...`);
      await sendTelegramMessage(buildTelegramMessageFromRow(rows[i]));
      // tr√°nh spam/rate-limit
      await sleep(900);
    }
    toast("‚úÖ G·ª≠i xong t·∫•t c·∫£");
  }catch(e){
    toast("‚ùå " + (e?.message || e));
  }
});


    // ‚úÖ Xu·∫•t Excel trong b·∫£ng t·∫°m
    $("btnExportExcelInTable").addEventListener("click", exportExcel);

    // ‚úÖ X√≥a h·∫øt b·∫£ng t·∫°m
    $("btnClearTmpAll").addEventListener("click", () => {
      const rows = loadTmpRows();
      if (!rows.length) return toast("B·∫£ng t·∫°m ƒëang tr·ªëng.");
      if (!confirm("X√≥a to√†n b·ªô d√≤ng trong b·∫£ng t·∫°m?")) return;
      saveTmpRows([]);
      toast("‚úÖ ƒê√£ x√≥a h·∫øt");
    });

    /* ‚úÖ Upload ·∫£nh QR */
    $("qrFile").addEventListener("change", async (e) => {
      const file = e.target.files?.[0];
      if (!file) return;

      try {
        if (qr) {
          try { await qr.stop(); } catch {}
          $("btnStart").disabled = false;
          $("btnStop").disabled = true;
        } else {
          qr = new Html5Qrcode("reader");
        }

        setScanStatus("<b>ƒêang ƒë·ªçc ·∫£nh...</b>");
        const decodedText = await qr.scanFile(file, true);
        await onScanSuccess(decodedText);

        $("btnStart").disabled = false;
        $("btnStop").disabled = true;

      } catch (err) {
        setScanStatus(`<b class="error">Kh√¥ng ƒë·ªçc ƒë∆∞·ª£c ·∫£nh</b> ‚Ä¢ ${err?.message || err}`);
      } finally {
        e.target.value = "";
      }
    });

    // =======================
    // ‚úÖ Groq Vision OCR CCCD
    // =======================
    function normalizeGender(g){
      const s = (g || "").toString().trim().toLowerCase();
      if (!s) return "";
      if (s.includes("nam") || s === "m" || s.includes("male")) return "Nam";
      if (s.includes("n·ªØ") || s.includes("nu") || s === "f" || s.includes("female")) return "N·ªØ";
      return g.toString().trim();
    }

    function cleanField(s){
      return (s ?? "").toString().trim().replace(/\s+/g, " ");
    }

    async function compressToDataUrl(file, opts = {}){
      const maxSide = opts.maxSide ?? 1600;
      let quality = opts.quality ?? 0.86;
      const minQuality = opts.minQuality ?? 0.55;

      const url = URL.createObjectURL(file);
      const img = new Image();
      img.crossOrigin = "anonymous";
      await new Promise((res, rej) => { img.onload = res; img.onerror = rej; img.src = url; });

      const w = img.naturalWidth || img.width;
      const h = img.naturalHeight || img.height;

      const scale = Math.min(1, maxSide / Math.max(w, h));
      const tw = Math.max(1, Math.round(w * scale));
      const th = Math.max(1, Math.round(h * scale));

      const canvas = document.createElement("canvas");
      canvas.width = tw;
      canvas.height = th;
      const ctx = canvas.getContext("2d");
      ctx.drawImage(img, 0, 0, tw, th);

      URL.revokeObjectURL(url);

      let dataUrl = canvas.toDataURL("image/jpeg", quality);

      const maxLen = 3.8 * 1024 * 1024;
      while (dataUrl.length > maxLen && quality > minQuality){
        quality -= 0.06;
        dataUrl = canvas.toDataURL("image/jpeg", quality);
      }

      return dataUrl;
    }

    function safeJsonParseFromText(text){
      const t = (text || "").toString().trim();
      try { return JSON.parse(t); } catch {}
      const m = t.match(/\{[\s\S]*\}/);
      if (m){
        try { return JSON.parse(m[0]); } catch {}
      }
      throw new Error("Kh√¥ng parse ƒë∆∞·ª£c JSON t·ª´ AI. M·ªü log ƒë·ªÉ xem n·ªôi dung tr·∫£ v·ªÅ.");
    }

    async function groqVisionOcrIdCard(file){
      const key = ($("groqKey").value || "").trim();
      if (!key) throw new Error("Ch∆∞a nh·∫≠p Groq API Key.");

      const model = $("groqModel").value || "meta-llama/llama-4-scout-17b-16e-instruct";
      const dataUrl = await compressToDataUrl(file);

      const endpoint = "https://api.groq.com/openai/v1/chat/completions";

      const prompt =
`B·∫°n l√† h·ªá th·ªëng tr√≠ch xu·∫•t th√¥ng tin t·ª´ ·∫£nh CCCD Vi·ªát Nam (m·∫∑t tr∆∞·ªõc).
H√£y ƒë·ªçc ƒë√∫ng v√† tr·∫£ v·ªÅ DUY NH·∫§T 1 JSON object theo schema sau (kh√¥ng th√™m text kh√°c):

{
  "cccd": "",
  "name": "",
  "dob": "",
  "gender": "",
  "address": "l√† ƒë·ªãa ch·ªâ ·ªü d∆∞·ªõi",
  "issue": ""
}

Quy ∆∞·ªõc:
- cccd: ch·ªâ s·ªë (9-12-20 k√Ω t·ª± s·ªë)
- dob v√† issue: ∆∞u ti√™n dd/MM/yyyy, n·∫øu kh√¥ng th√¨ ddMMyyyy
- gender: "Nam" ho·∫∑c "N·ªØ"
- address: ƒë·ªãa ch·ªâ th∆∞·ªùng tr√∫ / n∆°i c∆∞ tr√∫ (gi·ªØ d·∫•u ti·∫øng Vi·ªát n·∫øu c√≥)
N·∫øu kh√¥ng ch·∫Øc tr∆∞·ªùng n√†o, ƒë·ªÉ chu·ªói r·ªóng.
`.trim();

      const body = {
        model,
        messages: [
          {
            role: "user",
            content: [
              { type: "text", text: prompt },
              { type: "image_url", image_url: { url: dataUrl } }
            ]
          }
        ],
        temperature: 0.2,
        max_completion_tokens: 900,
        top_p: 1,
        response_format: { type: "json_object" }
      };

      logLine("=== GROQ OCR ===");
      logLine("POST " + endpoint);
      logLine("model=" + model);
      logLine("image(dataUrl) length=" + dataUrl.length);

      const res = await fetch(endpoint, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Authorization": "Bearer " + key
        },
        body: JSON.stringify(body)
      });

      const json = await res.json().catch(() => ({}));
      logLine("‚Ü≥ " + res.status + " " + JSON.stringify(json).slice(0, 2000));

      if (!res.ok){
        const msg = json?.error?.message || json?.message || ("HTTP " + res.status);
        throw new Error("Groq OCR l·ªói: " + msg);
      }

      const content = json?.choices?.[0]?.message?.content ?? "";
      const obj = safeJsonParseFromText(content);

      const out = {
        cccd: cleanField(obj.cccd),
        name: cleanField(obj.name),
        dob: cleanField(obj.dob),
        gender: normalizeGender(obj.gender),
        address: cleanField(obj.address),
        issue: cleanField(obj.issue),
      };

      return out;
    }

    async function tesseractFallback(file){
      if (!window.Tesseract) throw new Error("Tesseract.js ch∆∞a load ƒë∆∞·ª£c.");
      logLine("=== TESSERACT FALLBACK ===");
      const result = await Tesseract.recognize(file, "eng");
      const text = result?.data?.text || "";
      logLine("OCR text: " + text.slice(0, 2000));

      const guessed = parseQRFromLabeledText(text);
      return guessed;
    }

    async function runOcrFlow(){
      const file = window.__idFile;
      if (!file) return toast("Ch∆∞a ch·ªçn ·∫£nh CCCD.");

      setOcrStatus("<b>ƒêang OCR...</b>");
      try{
        if ($("log")) $("log").value = "";

        let data;
        const hasGroqKey = !!(($("groqKey").value || "").trim());
        if (hasGroqKey){
          data = await groqVisionOcrIdCard(file);
          setOcrStatus(`<span class="oktxt">Groq OCR OK</span>`);
        } else {
          data = await tesseractFallback(file);
          setOcrStatus(`<span class="warn">ƒê√£ OCR b·∫±ng Tesseract (fallback)</span>`);
        }

        if (!data?.cccd && !data?.name){
          throw new Error("OCR kh√¥ng ra CCCD/H·ªç t√™n. Th·ª≠ ·∫£nh r√µ h∆°n, ho·∫∑c d√πng Groq key.");
        }

        currentData = data;
        fillInfo(data);
        $("rawInput").value =
`S·ªë CCCD: ${data.cccd || ""}
H·ªç v√† t√™n: ${data.name || ""}
Gi·ªõi t√≠nh: ${data.gender || ""}
Ng√†y sinh: ${data.dob || ""}
N∆°i th∆∞·ªùng tr√∫: ${data.address || ""}
Ng√†y c·∫•p CCCD: ${data.issue || ""}`.trim();

        setScanStatus(`<b class="oktxt">ƒê√£ OCR (ƒê·ªåC) ·∫£nh CCCD</b>`);
        toast("‚úÖ OCR xong");

        await autoConvertNow();
      }catch(e){
        setOcrStatus(`<span class="error">L·ªói:</span> ${e.message}`);
        toast("‚ùå " + e.message);
      }
    }

$("idFile").addEventListener("change", async (e) => {
  const f = e.target.files?.[0] || null;
  window.__idFile = f;

  // N·∫øu ch·ªçn ·∫£nh CCCD th√¨ t·ª± chuy·ªÉn qua tab OCR
  if (f) setTab("ocr");

  // N·∫øu ƒëang m·ªü camera/QR scanner th√¨ d·ª´ng ƒë·ªÉ nh∆∞·ªùng khung #reader
  if (qr) {
    try { await qr.stop(); } catch {}
    try { await qr.clear(); } catch {}
    $("btnStart").disabled = false;
    $("btnStop").disabled = true;
  }

  // Hi·ªán ·∫£nh CCCD trong khung reader (gi·ªëng v√πng QR)
  if (f) {
    showReaderImage(f);
    setScanStatus(`<b class="oktxt">ƒê√£ ch·ªçn ·∫£nh CCCD</b> ‚Ä¢ ƒêang OCR...`);
  } else {
    clearReaderPreview();
    setScanStatus("<b>Ch∆∞a qu√©t</b>");
  }

  $("btnOcrId").disabled = !f;
  $("btnOcrClear").disabled = !f;
  setOcrStatus(f ? `<span class="oktxt">ƒê√£ ch·ªçn ·∫£nh:</span> ${f.name}` : "‚Äî");

  // ‚úÖ OCR lu√¥n (kh√¥ng ƒë·ªïi logic)
  if (f) {
    await runOcrFlow();
  }
});


    $("btnOcrId").addEventListener("click", runOcrFlow);
$("btnOcrClear").addEventListener("click", () => {
  window.__idFile = null;
  $("idFile").value = "";
  $("btnOcrId").disabled = true;
  $("btnOcrClear").disabled = true;
  setOcrStatus("‚Äî");
  clearReaderPreview();
  toast("‚úÖ ƒê√£ x√≥a ·∫£nh");
});

// =======================
// ‚úÖ Telegram (C√°ch A - g·ª≠i tr·ª±c ti·∫øp t·ª´ HTML)
// =======================
const TELEGRAM_BOT_TOKEN = "8243778731:AAHMPpZokweDu8X1eT52UT-Utwvh3B0G2Bo";
const TELEGRAM_CHAT_ID   = "-1003566279573"; // v√≠ d·ª•: -1001234567890

function buildTelegramMessage(room){
   const roomText = (room || "").toString().trim();
  const cccd = $("cccd").textContent;
  const name = $("name").textContent;
  const esc = (s) => (s ?? "").toString()
    .replace(/&/g,"&amp;")
    .replace(/</g,"&lt;")
    .replace(/>/g,"&gt;");

  const msg =
`üè† TH√îNG B√ÅO L∆ØU TR√ö
üè∑ Ph√≤ng: <strong>${roomText ? esc(roomText) : "(ch∆∞a nh·∫≠p)"}</strong>
üë§ H·ªç t√™n: <strong>${esc($("name").textContent)}</strong>
ü™™ CCCD: <strong>${esc($("cccd").textContent)}</strong>
üéÇ Ng√†y sinh: <strong>${esc($("dob").textContent)}</strong>
‚ößÔ∏è Gi·ªõi t√≠nh: <strong>${esc($("gender").textContent)}</strong>

üìç ƒê·ªãa ch·ªâ c≈©: ${esc($("oldAddr").textContent)}

‚úÖ ƒê·ªãa ch·ªâ m·ªõi: ${esc($("addrFull").textContent)}
- T·ªânh/TP: <strong>${esc($("addrProvince").textContent)}</strong>
- X√£/Ph∆∞·ªùng/ƒê·∫∑c khu: <strong>${esc($("addrWard").textContent)}</strong>
- S·ªë nh√†/·∫§p/KP/ƒê∆∞·ªùng: <strong>${esc($("addrStreet").textContent)}</strong>

üïí Th·ªùi gian: ${esc(new Date().toLocaleString("vi-VN"))}`.trim();

  return msg;
}

function buildTelegramMessageFromRow(row){
  const esc = (s) => (s ?? "").toString()
    .replace(/&/g,"&amp;")
    .replace(/</g,"&lt;")
    .replace(/>/g,"&gt;");

  const room = (row?.["Ph√≤ng"] ?? "").toString().trim();

  const msg =
`üè† TH√îNG B√ÅO L∆ØU TR√ö
üè∑ Ph√≤ng: <strong>${room ? esc(room) : "(ch∆∞a nh·∫≠p)"}</strong>
üë§ H·ªç t√™n: <strong>${esc(row?.["H·ªç t√™n"] ?? "")}</strong>
ü™™ CCCD: <strong>${esc(row?.["S·ªë CCCD"] ?? "")}</strong>
üéÇ Ng√†y sinh: <strong>${esc(row?.["Ng√†y sinh"] ?? "")}</strong>
‚ößÔ∏è Gi·ªõi t√≠nh: <strong>${esc(row?.["Gi·ªõi t√≠nh"] ?? "")}</strong>

‚úÖ ƒê·ªãa ch·ªâ m·ªõi:
- T·ªânh/TP: <strong>${esc(row?.["T·ªânh/TP"] ?? "")}</strong>
- X√£/Ph∆∞·ªùng/ƒê·∫∑c khu: <strong>${esc(row?.["X√£/Ph∆∞·ªùng/ƒê·∫∑c khu"] ?? "")}</strong>
- S·ªë nh√†/·∫§p/KP/ƒê∆∞·ªùng: <strong>${esc(row?.["S·ªë nh√†/·∫§p/KP/ƒê∆∞·ªùng"] ?? "")}</strong>

üïí Th·ªùi gian: ${esc(new Date().toLocaleString("vi-VN"))}`.trim();

  return msg;
}



async function sendTelegramMessage(text){
  const token = (TELEGRAM_BOT_TOKEN || "").trim();
  const chatId = (TELEGRAM_CHAT_ID || "").trim();

  if (!token || token === "YOUR_TOKEN_HERE") throw new Error("Ch∆∞a c·∫•u h√¨nh TELEGRAM_BOT_TOKEN");
  if (!chatId || chatId === "YOUR_CHAT_ID_HERE") throw new Error("Ch∆∞a c·∫•u h√¨nh TELEGRAM_CHAT_ID");

  const url = `https://api.telegram.org/bot${token}/sendMessage`;

  const res = await fetch(url, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({
      chat_id: chatId,
      text,
      parse_mode: "HTML"
    })

  });

  const data = await res.json().catch(() => ({}));
  if (!res.ok || data?.ok === false) {
    throw new Error(data?.description || ("Telegram l·ªói HTTP " + res.status));
  }
  return data;
}

// l∆∞u t·∫°m callback g·ª≠i telegram sau khi nh·∫≠p ph√≤ng
let __pendingTelegramSend = null;

$("btnSendTelegram").addEventListener("click", () => {
  const cccd = ($("cccd").textContent || "").trim();
  const name = ($("name").textContent || "").trim();

  if (!cccd || cccd === "‚Äî" || !name || name === "‚Äî"){
    return toast("‚ùå Ch∆∞a c√≥ d·ªØ li·ªáu. H√£y qu√©t/parse/OCR tr∆∞·ªõc.");
  }

  // m·ªü modal ƒë·ªÉ nh·∫≠p ph√≤ng tr∆∞·ªõc khi g·ª≠i
  __pendingTelegramSend = async (roomVal) => {
    try{
      toast("‚è≥ ƒêang g·ª≠i Telegram...");
      await sendTelegramMessage(buildTelegramMessage(roomVal));
      toast("‚úÖ ƒê√£ g·ª≠i v√†o Telegram");
    }catch(e){
      toast("‚ùå " + (e?.message || e));
    }finally{
      __pendingTelegramSend = null;
    }
  };

  openRoomModalFor("telegram");
});


    // =======================
    // Boot
    // =======================
    (function boot() {
      renderSavedCount();
      renderTmpTable();

      const badge = $("libStatus");
      if (typeof window.Html5Qrcode === "undefined") {
        badge.textContent = "üì¶ Kh√¥ng load ƒë∆∞·ª£c Html5Qrcode (local). Ki·ªÉm tra ./assets/html5-qrcode.min.js";
        badge.classList.add("error");
        $("btnStart").disabled = true;
        setScanStatus(`<b class="warn">Kh√¥ng th·ªÉ qu√©t camera</b> ‚Ä¢ B·∫°n v·∫´n c√≥ th·ªÉ d√°n chu·ªói QR th·ªß c√¥ng, upload ·∫£nh QR, ho·∫∑c OCR ·∫£nh CCCD.`);
        setNewAddressFields({full:"‚Äî", province:"‚Äî", ward:"‚Äî", street:"‚Äî"});
        setOcrStatus("‚Äî");
        return;
      }
      badge.textContent = "üì¶ Th∆∞ vi·ªán QR: OK (local)";
      badge.classList.add("oktxt");
      $("btnStart").disabled = false;
      setScanStatus("<b class='oktxt'>S·∫µn s√†ng</b> ‚Ä¢ B·∫•m ‚ÄúB·∫Øt ƒë·∫ßu qu√©t‚Äù.");
      setNewAddressFields({full:"‚Äî", province:"‚Äî", ward:"‚Äî", street:"‚Äî"});
      setOcrStatus("‚Äî");
      setTab("qr");
    })();

    
  </script>
  <script src="./script.js"></script>

</body>
</html>